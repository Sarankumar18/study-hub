# 1D Dynamic Programming

> Build optimal solutions by solving overlapping subproblems along a single dimension—use a 1D DP array where each state depends on previous states. Master both bottom-up tabulation and top-down memoization for FAANG interviews.

## What Is This Pattern?

**1D Dynamic Programming** solves optimization or counting problems where the optimal answer at position `i` depends on answers at positions `0..i-1` (or a small fixed window). The key insight: instead of recomputing the same subproblems recursively, we store results in a 1D array `dp[]` and reuse them. This transforms exponential recursion into polynomial time.

Two standard implementations: **bottom-up tabulation** (fill `dp[0]`, `dp[1]`, ... forward) and **top-down memoization** (recursive with cache). Tabulation is often space-optimizable to O(1) when only a few previous states are needed; memoization preserves the recursive structure and is easier to derive from the recurrence.

Use 1D DP when subproblems **overlap** and exhibit **optimal substructure**—the optimal solution contains optimal solutions to subproblems. Classic recurrences: `dp[i] = f(dp[i-1], dp[i-2], ...)` for linear chains, `dp[i] = max/min over j < i of ...` for "pick best previous state" problems.

## When to Use

- Problem asks for **maximum/minimum** or **count** over a sequence.
- Optimal choice at step `i` depends on choices at earlier steps.
- Brute-force recursion would revisit the **same subproblems** many times.
- You see phrases like "distinct ways", "minimum cost", "longest subsequence", "can you form X".
- Input is a **1D array or string** with a natural left-to-right order.

## How to Identify

```
Is the input a 1D sequence (array or string)?
    NO → Consider 2D DP or graph-based
    YES ↓

Does the answer at position i depend on answers at earlier positions?
    NO → Maybe greedy or simple scan
    YES ↓

Do subproblems overlap (same subproblem solved multiple times)?
    YES → 1D DYNAMIC PROGRAMMING

Is the recurrence a function of dp[i-1], dp[i-2], or dp[j] for j < i?
    YES → Build dp[] left-to-right (tabulation) or memoize recursively
```

## Core Template (Pseudocode)

### Bottom-Up Tabulation

```
FUNCTION solve(input):
    n = length(input)
    dp[0..n] = INITIAL_VALUE  // 0, INF, or base cases

    dp[0] = BASE_CASE
    FOR i FROM 1 TO n:
        dp[i] = RECURRENCE(dp[i-1], dp[i-2], ... input[i])

    RETURN dp[n]
```

### Top-Down Memoization

```
FUNCTION solve(input):
    memo = MAP or ARRAY (uninitialized = -1 or null)
    RETURN solveRecursive(input, n, memo)

FUNCTION solveRecursive(input, i, memo):
    IF i == 0 (or base case):
        RETURN BASE_VALUE
    IF memo[i] already computed:
        RETURN memo[i]

    result = RECURRENCE(solveRecursive(i-1), solveRecursive(i-2), ...)
    memo[i] = result
    RETURN result
```

### Space-Optimized (When dp[i] Depends Only on dp[i-1], dp[i-2])

```
FUNCTION solve(input):
    prev2 = BASE_0   // dp[0]
    prev1 = BASE_1   // dp[1]

    FOR i FROM 2 TO n:
        curr = RECURRENCE(prev1, prev2, input[i])
        prev2 = prev1
        prev1 = curr

    RETURN prev1
```

## Core Template (Java)

### Bottom-Up Tabulation

```java
public int solve(int[] nums) {
    int n = nums.length;
    int[] dp = new int[n + 1];
    dp[0] = 0;  // base case

    for (int i = 1; i <= n; i++) {
        dp[i] = recurrence(dp, nums, i);
    }
    return dp[n];
}

private int recurrence(int[] dp, int[] nums, int i) {
    // e.g., dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);
    return 0;  // problem-specific
}
```

### Top-Down Memoization

```java
public int solve(int[] nums) {
    int n = nums.length;
    int[] memo = new int[n + 1];
    Arrays.fill(memo, -1);
    return solveRec(nums, n, memo);
}

private int solveRec(int[] nums, int i, int[] memo) {
    if (i == 0) return 0;  // base case
    if (memo[i] != -1) return memo[i];

    int result = recurrence(nums, i, memo);
    memo[i] = result;
    return result;
}

private int recurrence(int[] nums, int i, int[] memo) {
    // e.g., return Math.max(solveRec(nums, i-1, memo), solveRec(nums, i-2, memo) + nums[i-1]);
    return 0;
}
```

### Space-Optimized (Two Variables)

```java
public int solve(int[] nums) {
    int prev2 = 0, prev1 = nums[0];
    for (int i = 1; i < nums.length; i++) {
        int curr = Math.max(prev1, prev2 + nums[i]);
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

## Complexity Cheat Sheet

| Approach       | Time        | Space      | When to Use                              |
|----------------|-------------|------------|------------------------------------------|
| Tabulation     | O(n)        | O(n)       | Standard; all subproblems needed          |
| Memoization    | O(n)        | O(n)       | Natural recursion; not all states needed  |
| Space-opt      | O(n)        | O(1)       | dp[i] depends only on O(1) prev states    |
| LIS-style      | O(n²)       | O(n)       | dp[i] = best over all j < i               |
| LIS + BS       | O(n log n)  | O(n)       | Greedy + binary search (special case)     |

---

## Problems with Full Solutions

### Easy (3)

---

#### Problem: [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/) (LeetCode #70)

- **Intuition:** To reach step `n`, you came from step `n-1` (1 step) or `n-2` (2 steps). Count of ways = ways(n-1) + ways(n-2). Fibonacci-style recurrence.
- **Brute Force:** Recursive: climb(n) = climb(n-1) + climb(n-2) without memoization; many overlapping subproblems. Time O(2^n) — binary tree of choices, no memo; Space O(n) — recursion stack depth.
- **Approach:** Base: `dp[0]=1`, `dp[1]=1`. Recurrence: `dp[i] = dp[i-1] + dp[i-2]`. Space-optimize to two variables.
- **LeetCode Signature:** `public int climbStairs(int n)`

**Tabulation + Space-Optimized:**

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 1) return 1;
        int prev2 = 1, prev1 = 1;
        for (int i = 2; i <= n; i++) {
            int curr = prev1 + prev2;
            prev2 = prev1;
            prev1 = curr;
        }
        return prev1;
    }
}
```

**Memoization:**

```java
class Solution {
    public int climbStairs(int n) {
        int[] memo = new int[n + 1];
        Arrays.fill(memo, -1);
        return climbRec(n, memo);
    }

    private int climbRec(int n, int[] memo) {
        if (n <= 1) return 1;
        if (memo[n] != -1) return memo[n];
        memo[n] = climbRec(n - 1, memo) + climbRec(n - 2, memo);
        return memo[n];
    }
}
```

- **Complexity:** Time O(n) — single pass filling n states; Space O(1) tabulation — two prev variables / O(n) memoization — memo array.

---

#### Problem: [Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/) (LeetCode #746)

- **Intuition:** You can start at index 0 or 1. From step `i`, pay `cost[i]` and jump to `i+1` or `i+2`. Find minimum cost to reach beyond the last index. `dp[i]` = min cost to reach step `i` (and step from there).
- **Brute Force:** Recursive: try both moves from each step and explore all paths without memoization. Time O(2^n) — two choices per step, exponential paths; Space O(n) — recursion depth.
- **Approach:** Base: `dp[0]=cost[0]`, `dp[1]=cost[1]`. Recurrence: `dp[i] = cost[i] + min(dp[i-1], dp[i-2])`. Answer: `min(dp[n-1], dp[n-2])`.
- **LeetCode Signature:** `public int minCostClimbingStairs(int[] cost)`

**Tabulation + Space-Optimized:**

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int prev2 = cost[0], prev1 = cost[1];
        for (int i = 2; i < n; i++) {
            int curr = cost[i] + Math.min(prev1, prev2);
            prev2 = prev1;
            prev1 = curr;
        }
        return Math.min(prev1, prev2);
    }
}
```

**Memoization:**

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] memo = new int[n];
        Arrays.fill(memo, -1);
        return Math.min(minCostRec(cost, 0, memo), minCostRec(cost, 1, memo));
    }

    private int minCostRec(int[] cost, int i, int[] memo) {
        if (i >= cost.length) return 0;
        if (memo[i] != -1) return memo[i];
        memo[i] = cost[i] + Math.min(minCostRec(cost, i + 1, memo), minCostRec(cost, i + 2, memo));
        return memo[i];
    }
}
```

- **Complexity:** Time O(n) — one pass over cost array; Space O(1) tabulation — two variables / O(n) memoization — memo array.

---

#### Problem: [House Robber](https://leetcode.com/problems/house-robber/) (LeetCode #198)

- **Intuition:** At house `i`, either rob it (add `nums[i]` and skip `i-1`) or skip it (take best from `i-1`). `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`.
- **Brute Force:** Recursive: at each house either take or skip, explore all combinations without memoization. Time O(2^n) — take/skip per house, no memo; Space O(n) — recursion stack.
- **Approach:** Base: `dp[0]=nums[0]`, `dp[1]=max(nums[0], nums[1])`. Recurrence as above. Space-optimize with two variables.
- **LeetCode Signature:** `public int rob(int[] nums)`

**Tabulation + Space-Optimized:**

```java
class Solution {
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        int prev2 = nums[0], prev1 = Math.max(nums[0], nums[1]);
        for (int i = 2; i < nums.length; i++) {
            int curr = Math.max(prev1, prev2 + nums[i]);
            prev2 = prev1;
            prev1 = curr;
        }
        return prev1;
    }
}
```

**Memoization:**

```java
class Solution {
    public int rob(int[] nums) {
        int[] memo = new int[nums.length];
        Arrays.fill(memo, -1);
        return robRec(nums, nums.length - 1, memo);
    }

    private int robRec(int[] nums, int i, int[] memo) {
        if (i < 0) return 0;
        if (memo[i] != -1) return memo[i];
        int take = nums[i] + (i >= 2 ? robRec(nums, i - 2, memo) : 0);
        int skip = robRec(nums, i - 1, memo);
        memo[i] = Math.max(take, skip);
        return memo[i];
    }
}
```

- **Complexity:** Time O(n) — one pass, each house O(1) work; Space O(1) tabulation — prev2, prev1 only / O(n) memoization — memo array.

---

### Medium (5)

---

#### Problem: [House Robber II](https://leetcode.com/problems/house-robber-ii/) (LeetCode #213)

- **Intuition:** Houses are arranged in a circle—first and last are adjacent. Run House Robber twice: once excluding first house, once excluding last house. Answer = `max(rob(nums[1..n-1]), rob(nums[0..n-2]))`.
- **Brute Force:** Same as House Robber: recursive take/skip with circular constraint; try all valid subsets. Time O(2^n) — take/skip per house, exponential; Space O(n) — recursion depth.
- **Approach:** Use a helper that solves linear House Robber on a subarray. Call it for `[1, n-1]` and `[0, n-2]`; handle `n==1` edge case.
- **LeetCode Signature:** `public int rob(int[] nums)`

**Tabulation (Space-Optimized Helper):**

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];
        return Math.max(robLinear(nums, 0, n - 2), robLinear(nums, 1, n - 1));
    }

    private int robLinear(int[] nums, int start, int end) {
        int prev2 = 0, prev1 = 0;
        for (int i = start; i <= end; i++) {
            int curr = Math.max(prev1, prev2 + nums[i]);
            prev2 = prev1;
            prev1 = curr;
        }
        return prev1;
    }
}
```

**Memoization:**

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];
        int[] memo1 = new int[n];
        int[] memo2 = new int[n];
        Arrays.fill(memo1, -1);
        Arrays.fill(memo2, -1);
        return Math.max(robRec(nums, 0, n - 2, memo1), robRec(nums, 1, n - 1, memo2));
    }

    private int robRec(int[] nums, int start, int i, int[] memo) {
        if (i < start) return 0;
        int idx = i - start;
        if (memo[idx] != -1) return memo[idx];
        int take = nums[i] + (i >= start + 2 ? robRec(nums, start, i - 2, memo) : 0);
        int skip = robRec(nums, start, i - 1, memo);
        memo[idx] = Math.max(take, skip);
        return memo[idx];
    }
}
```

- **Complexity:** Time O(n) — two linear passes over subarrays; Space O(1) tabulation — helper uses two vars / O(n) memoization — memo per subarray.

---

#### Problem: [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) (LeetCode #300)

- **Intuition:** `dp[i]` = length of LIS ending at `i` (must include `nums[i]`). For each `i`, look at all `j < i` where `nums[j] < nums[i]` and take `max(dp[j]) + 1`.
- **Brute Force:** Enumerate all 2^n subsequences, check if each is increasing, track max length. Time O(2^n · n) — 2^n subsets, each O(n) to validate; Space O(n) — recursion stack.
- **Approach:** Initialize `dp[i]=1` for all `i`. For each `i`, for each `j < i` with `nums[j] < nums[i]`: `dp[i] = max(dp[i], dp[j] + 1)`. Answer = `max(dp[])`.
- **LeetCode Signature:** `public int lengthOfLIS(int[] nums)`

**Tabulation:**

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int maxLen = 1;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxLen = Math.max(maxLen, dp[i]);
        }
        return maxLen;
    }
}
```

**Memoization:**

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        int[] memo = new int[n];
        Arrays.fill(memo, -1);
        int maxLen = 1;
        for (int i = 0; i < n; i++) {
            maxLen = Math.max(maxLen, lisEndingAt(nums, i, memo));
        }
        return maxLen;
    }

    private int lisEndingAt(int[] nums, int i, int[] memo) {
        if (memo[i] != -1) return memo[i];
        int best = 1;
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                best = Math.max(best, lisEndingAt(nums, j, memo) + 1);
            }
        }
        memo[i] = best;
        return best;
    }
}
```

- **Complexity:** Time O(n²) — for each i, scan all j < i to find best predecessor; Space O(n) — dp array.
- **Note:** O(n log n) solution exists with greedy + binary search but is a pattern variation.

---

#### Problem: [Word Break](https://leetcode.com/problems/word-break/) (LeetCode #139)

- **Intuition:** `dp[i]` = can we segment `s[0..i-1]`? For each `i`, try all word endings: if `s[j..i-1]` is a word and `dp[j]` is true, then `dp[i]=true`.
- **Brute Force:** Try all 2^(n-1) ways to split the string at positions 1..n-1; check if each segment is in dict. Time O(2^n · m) — 2^(n-1) splits, each dict lookup O(m); Space O(n) — recursion depth.
- **Approach:** Base: `dp[0]=true`. For `i` from 1 to n: for each `j` from 0 to i-1, if `dp[j]` and `wordDict.contains(s.substring(j,i))`, set `dp[i]=true`.
- **LeetCode Signature:** `public boolean wordBreak(String s, List<String> wordDict)`

**Tabulation:**

```java
class Solution {
    public boolean wordBreak(String s, java.util.List<String> wordDict) {
        int n = s.length();
        var set = new java.util.HashSet<>(wordDict);
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && set.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
}
```

**Memoization:**

```java
class Solution {
    public boolean wordBreak(String s, java.util.List<String> wordDict) {
        var set = new java.util.HashSet<>(wordDict);
        Boolean[] memo = new Boolean[s.length() + 1];
        return wordBreakRec(s, 0, set, memo);
    }

    private boolean wordBreakRec(String s, int start, java.util.Set<String> set, Boolean[] memo) {
        if (start == s.length()) return true;
        if (memo[start] != null) return memo[start];
        for (int end = start + 1; end <= s.length(); end++) {
            if (set.contains(s.substring(start, end)) && wordBreakRec(s, end, set, memo)) {
                memo[start] = true;
                return true;
            }
        }
        memo[start] = false;
        return false;
    }
}
```

- **Complexity:** Time O(n² · m) — n positions, each tries O(n) splits with O(m) substring+lookup; Space O(n) — dp boolean array.

---

#### Problem: [Coin Change](https://leetcode.com/problems/coin-change/) (LeetCode #322)

- **Intuition:** `dp[a]` = minimum coins to make amount `a`. For each coin `c`, `dp[a] = min(dp[a], 1 + dp[a-c])` if `a >= c`.
- **Brute Force:** Recursive: for amount a, try each coin and recurse on a-c; explore all combinations without memo. Time O(amount^k) — k choices per level, amount levels; Space O(amount) — recursion depth.
- **Approach:** Initialize `dp[0]=0`, `dp[a]=INF` for a>0. For each amount from 1 to amount, for each coin: if `a >= coins[j]`, `dp[a] = min(dp[a], 1 + dp[a-coins[j]])`. Return `dp[amount]` or -1 if still INF.
- **LeetCode Signature:** `public int coinChange(int[] coins, int amount)`

**Tabulation:**

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        java.util.Arrays.fill(dp, amount + 1);  // INF
        dp[0] = 0;
        for (int a = 1; a <= amount; a++) {
            for (int c : coins) {
                if (a >= c) {
                    dp[a] = Math.min(dp[a], 1 + dp[a - c]);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

**Memoization:**

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] memo = new int[amount + 1];
        int result = coinRec(coins, amount, memo);
        return result == Integer.MAX_VALUE ? -1 : result;
    }

    private int coinRec(int[] coins, int amount, int[] memo) {
        if (amount == 0) return 0;
        if (amount < 0) return Integer.MAX_VALUE;
        if (memo[amount] != 0) return memo[amount];
        int minCoins = Integer.MAX_VALUE;
        for (int c : coins) {
            int sub = coinRec(coins, amount - c, memo);
            if (sub != Integer.MAX_VALUE) {
                minCoins = Math.min(minCoins, 1 + sub);
            }
        }
        memo[amount] = minCoins;
        return minCoins;
    }
}
```

- **Complexity:** Time O(amount · coins.length) — fill amount cells, each tries all coins; Space O(amount) — dp array.
- **Note:** Memoization uses 0 to mean unvisited; use a different sentinel if 0 is a valid result (here it's not).

---

#### Problem: [Decode Ways](https://leetcode.com/problems/decode-ways/) (LeetCode #91)

- **Intuition:** `dp[i]` = ways to decode `s[0..i-1]`. Single digit valid (1-9): add `dp[i-1]`. Two digits valid (10-26): add `dp[i-2]`. `dp[i] = dp[i-1] + dp[i-2]` (when both valid).
- **Brute Force:** Recursive: at each index try decode 1 char or 2 chars, branch without memoization. Time O(2^n) — two choices per char, no memo; Space O(n) — recursion depth.
- **Approach:** Base: `dp[0]=1`. For each `i`: if `s[i-1]!='0'` add `dp[i-1]`; if `i>=2` and two-char is valid add `dp[i-2]`. Handle leading zeros.
- **LeetCode Signature:** `public int numDecodings(String s)`

**Tabulation + Space-Optimized:**

```java
class Solution {
    public int numDecodings(String s) {
        if (s.charAt(0) == '0') return 0;
        int n = s.length();
        int prev2 = 1, prev1 = 1;
        for (int i = 1; i < n; i++) {
            int curr = 0;
            int one = s.charAt(i) - '0';
            int two = (s.charAt(i - 1) - '0') * 10 + one;
            if (one >= 1 && one <= 9) curr += prev1;
            if (two >= 10 && two <= 26) curr += prev2;
            prev2 = prev1;
            prev1 = curr;
        }
        return prev1;
    }
}
```

**Memoization:**

```java
class Solution {
    public int numDecodings(String s) {
        int[] memo = new int[s.length() + 1];
        Arrays.fill(memo, -1);
        return decodeRec(s, 0, memo);
    }

    private int decodeRec(String s, int i, int[] memo) {
        if (i == s.length()) return 1;
        if (s.charAt(i) == '0') return 0;
        if (memo[i] != -1) return memo[i];
        int count = decodeRec(s, i + 1, memo);
        if (i + 1 < s.length()) {
            int two = (s.charAt(i) - '0') * 10 + (s.charAt(i + 1) - '0');
            if (two >= 10 && two <= 26) count += decodeRec(s, i + 2, memo);
        }
        memo[i] = count;
        return count;
    }
}
```

- **Complexity:** Time O(n) — single pass over string; Space O(1) tabulation — two prev vars / O(n) memoization — memo array.

---

### Hard (3)

---

#### Problem: [Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/) (LeetCode #32)

- **Intuition:** `dp[i]` = length of longest valid parentheses ending at `i`. Only `)` can close. If `s[i]==')'` and `s[i-1]=='(', dp[i]=dp[i-2]+2`. If `s[i]==')'` and we have a matched `(` before a valid segment, `dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]`.
- **Brute Force:** For each starting index, check every possible substring if it's valid parentheses; O(n²) substrings, each O(n) to validate. Time O(n³) — O(n²) substrings, each O(n) validation; Space O(n) — recursion or stack.
- **Approach:** Track opening paren index. For `)`: if prev is `(`, we close a pair; else jump back over a valid segment to find matching `(`. Combine lengths.
- **LeetCode Signature:** `public int longestValidParentheses(String s)`

**Tabulation:**

```java
class Solution {
    public int longestValidParentheses(String s) {
        int n = s.length();
        if (n < 2) return 0;
        int[] dp = new int[n];
        int maxLen = 0;
        for (int i = 1; i < n; i++) {
            if (s.charAt(i) == ')') {
                if (s.charAt(i - 1) == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                    dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] >= 2 ? dp[i - dp[i - 1] - 2] : 0);
                }
                maxLen = Math.max(maxLen, dp[i]);
            }
        }
        return maxLen;
    }
}
```

**Stack-based (alternative, not memoization but worth knowing):**

```java
// Alternative O(n) time, O(n) space with stack
class Solution {
    public int longestValidParentheses(String s) {
        var stack = new java.util.ArrayDeque<Integer>();
        stack.push(-1);
        int maxLen = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            } else {
                stack.pop();
                if (stack.isEmpty()) stack.push(i);
                else maxLen = Math.max(maxLen, i - stack.peek());
            }
        }
        return maxLen;
    }
}
```

- **Complexity:** Time O(n) — single pass, each index O(1) dp update; Space O(n) — dp array.
- **Note:** Memoization is less natural here; DP tabulation is the standard 1D DP approach.

---

#### Problem: [Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/) (LeetCode #152)

- **Intuition:** Negative numbers can flip sign. Track both `maxProd` and `minProd` at each position—multiplying by negative swaps them. `maxProd[i] = max(nums[i], maxProd[i-1]*nums[i], minProd[i-1]*nums[i])`.
- **Brute Force:** Enumerate all O(n²) subarrays, compute product of each, track max. Time O(n³) — O(n²) subarrays, each O(n) product / O(n²) with prefix; Space O(1) — constant extra variables.
- **Approach:** Single pass: maintain `maxSoFar` and `minSoFar`. At each element, new max = max(cur, cur*maxSoFar, cur*minSoFar), new min = min(cur, cur*maxSoFar, cur*minSoFar). Track global max.
- **LeetCode Signature:** `public int maxProduct(int[] nums)`

**Tabulation (Space-Optimized):**

```java
class Solution {
    public int maxProduct(int[] nums) {
        int maxProd = nums[0], minProd = nums[0], result = nums[0];
        for (int i = 1; i < nums.length; i++) {
            int cur = nums[i];
            int tmpMax = Math.max(cur, Math.max(maxProd * cur, minProd * cur));
            minProd = Math.min(cur, Math.min(maxProd * cur, minProd * cur));
            maxProd = tmpMax;
            result = Math.max(result, maxProd);
        }
        return result;
    }
}
```

**Memoization (explicit dp arrays for clarity):**

```java
class Solution {
    public int maxProduct(int[] nums) {
        int n = nums.length;
        int[] maxDp = new int[n];
        int[] minDp = new int[n];
        maxDp[0] = minDp[0] = nums[0];
        int result = nums[0];
        for (int i = 1; i < n; i++) {
            int cur = nums[i];
            maxDp[i] = Math.max(cur, Math.max(maxDp[i-1] * cur, minDp[i-1] * cur));
            minDp[i] = Math.min(cur, Math.min(maxDp[i-1] * cur, minDp[i-1] * cur));
            result = Math.max(result, maxDp[i]);
        }
        return result;
    }
}
```

- **Complexity:** Time O(n) — single pass through array; Space O(1) optimized — two variables / O(n) explicit dp — maxDp and minDp arrays.

---

#### Problem: [Jump Game II](https://leetcode.com/problems/jump-game-ii/) (LeetCode #45)

- **Intuition:** `dp[i]` = minimum jumps to reach index `i`. For each `i`, from every `j < i` where `j + nums[j] >= i`, `dp[i] = min(dp[i], dp[j] + 1)`. Greedy BFS is faster: track farthest we can reach in current "level", count jumps.
- **Brute Force:** BFS/DFS: explore all possible jump sequences from index 0; without pruning, tries many redundant paths. Time O(k^n) — up to k choices per step, n steps; Space O(n) — recursion/queue.
- **Approach:** Greedy: `end` = boundary of current jump, `farthest` = max reach. When `i > end`, need another jump, `end = farthest`. Count jumps. DP: `dp[i] = 1 + min(dp[j])` for all j reachable to i.
- **LeetCode Signature:** `public int jump(int[] nums)`

**Tabulation (Classic 1D DP):**

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, n);  // INF
        dp[0] = 0;
        for (int i = 0; i < n; i++) {
            int maxStep = nums[i];
            for (int j = 1; j <= maxStep && i + j < n; j++) {
                dp[i + j] = Math.min(dp[i + j], dp[i] + 1);
            }
        }
        return dp[n - 1];
    }
}
```

**Greedy BFS (faster, O(n)):**

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        if (n <= 1) return 0;
        int jumps = 0, end = 0, farthest = 0;
        for (int i = 0; i < n - 1; i++) {
            farthest = Math.max(farthest, i + nums[i]);
            if (i == end) {
                jumps++;
                end = farthest;
                if (end >= n - 1) break;
            }
        }
        return jumps;
    }
}
```

**Memoization:**

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int[] memo = new int[n];
        Arrays.fill(memo, -1);
        return jumpRec(nums, 0, memo);
    }

    private int jumpRec(int[] nums, int i, int[] memo) {
        if (i >= nums.length - 1) return 0;
        if (memo[i] != -1) return memo[i];
        int minJumps = nums.length;
        for (int j = 1; j <= nums[i]; j++) {
            minJumps = Math.min(minJumps, 1 + jumpRec(nums, i + j, memo));
        }
        memo[i] = minJumps;
        return minJumps;
    }
}
```

- **Complexity:** Time O(n²) DP — for each i, update up to nums[i] future cells / O(n) greedy — single pass; Space O(n) — dp array.

---

## Common Mistakes

1. **Wrong base cases:** Off-by-one in `dp[0]` vs `dp[1]`—match recurrence to problem (0-indexed vs 1-indexed).
2. **Order of iteration:** In tabulation, iterate in an order that guarantees dependencies are computed first (usually left-to-right).
3. **Integer overflow:** Use `long` when `dp[i]` can exceed `Integer.MAX_VALUE` (e.g., large counts).
4. **Sentinel for "impossible":** Use a value that cannot be confused with valid answers (e.g., `amount+1` for coin change, `n` for min jumps).
5. **Memoization base case:** Return base values before checking memo to avoid storing wrong values.
6. **Space optimization:** Only collapse when `dp[i]` depends on a fixed window (e.g., `i-1`, `i-2`); LIS-style needs full array.
7. **String indices:** `dp[i]` often means "prefix of length i"; `s.substring(j, i)` is `s[j..i-1]`.

## Pattern Variations

| Variation            | Example               | Recurrence Type                    |
|----------------------|-----------------------|------------------------------------|
| Linear chain         | Climbing Stairs       | `dp[i] = f(dp[i-1], dp[i-2])`      |
| Pick or skip         | House Robber          | `dp[i] = max(take, skip)`          |
| Enumerate predecessors| LIS                  | `dp[i] = 1 + max(dp[j])` j&lt;i     |
| Substring/segment    | Word Break            | `dp[i] = OR over j of dp[j] && word|
| Unbounded choice     | Coin Change           | `dp[a] = min over coins`           |
| Two states           | Max Product           | Track both max and min             |
| Interval/circle      | House Robber II       | Run linear solver on subarrays    |
| Greedy + DP          | Jump Game II          | BFS/level-order faster than DP     |
