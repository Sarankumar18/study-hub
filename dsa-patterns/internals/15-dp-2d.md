# 2D Dynamic Programming

> Solve problems with optimal substructure and overlapping subproblems by building a 2D table—grid DP (paths, min cost), two-sequence DP (LCS, edit distance), or 2D knapsack (count ways, target sum). Essential for FAANG string/grid optimization questions.

## What Is This Pattern?

**2D Dynamic Programming** extends 1D DP by defining state as two dimensions—commonly `(i, j)` representing positions in two inputs (two strings, grid rows/columns, or item index + capacity). You fill a table `dp[i][j]` where each cell depends on previously computed cells. Three main families:

1. **Grid DP:** `dp[r][c]` = best value reaching cell `(r,c)`. Fill row by row or column by column. Used for path counting, min/max path sum, obstacles.
2. **Two-sequence DP:** `dp[i][j]` = best result for prefixes `s1[0..i)` and `s2[0..j)`. Used for LCS, edit distance, interleaving, regex matching.
3. **2D Knapsack:** `dp[i][j]` = result using first `i` items for capacity/sum `j`. Used for coin change 2, target sum, subset-sum variants.

The pattern applies when the problem has **optimal substructure** (optimal solution uses optimal solutions to subproblems) and **overlapping subproblems** (same subproblems recur). Tabulation (bottom-up) or memoization (top-down) both work—choose based on clarity and space optimization needs.

## When to Use

- Problem involves **two sequences** (strings, arrays) or a **grid**.
- You need to find **longest/maximum/minimum** something involving both inputs.
- Problem asks to **count ways** or **check existence** with constraints on two dimensions.
- Subproblems naturally depend on **two indices** (e.g., "first i chars of s1, first j chars of s2").
- Phrases: "longest common", "edit distance", "minimum path sum", "number of ways", "can s3 be formed by interleaving s1 and s2".

## How to Identify

```
Does the problem involve two sequences or a grid?
    NO → Maybe 1D DP or greedy
    YES ↓

Does the answer depend on matching/aligning prefixes of two inputs?
    YES → TWO-SEQUENCE DP (LCS, edit distance, interleaving)
    NO ↓

Is there a grid with path/cost constraints?
    YES → GRID DP (paths, min sum, obstacles)
    NO ↓

Is there a choice of items and a target (sum, amount)?
    YES → 2D KNAPSACK (or 1D if order doesn't matter)
```

## Core Template (Pseudocode)

### Grid DP (Path Counting / Min Cost)

```
FUNCTION gridDP(m, n):
    dp[0..m][0..n] = base values (often 0 or ∞)
    dp[0][0] = initial value (e.g., 1 for paths, grid[0][0] for min sum)

    FOR r FROM 0 TO m-1:
        FOR c FROM 0 TO n-1:
            IF (r,c) is blocked: dp[r][c] = 0 (or ∞)
            ELSE: dp[r][c] = combine(dp[r-1][c], dp[r][c-1], grid[r][c])

    RETURN dp[m-1][n-1]
```

### Two-Sequence DP (LCS, Edit Distance)

```
FUNCTION twoSeqDP(s1, s2):
    m, n = len(s1), len(s2)
    dp[0..m][0..n]   // dp[i][j] = result for s1[0..i) and s2[0..j)

    FOR i FROM 0 TO m:
        dp[i][0] = base(s1[0..i])
    FOR j FROM 0 TO n:
        dp[0][j] = base(s2[0..j])

    FOR i FROM 1 TO m:
        FOR j FROM 1 TO n:
            IF s1[i-1] == s2[j-1]:
                dp[i][j] = f_match(dp[i-1][j-1])
            ELSE:
                dp[i][j] = f_mismatch(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])

    RETURN dp[m][n]
```

### 2D Knapsack (Count Ways, Unbounded)

```
FUNCTION knapsack2D(items, capacity):
    dp[0..items.length][0..capacity]
    dp[i][0] = 1 for all i   // one way to make 0

    FOR i FROM 0 TO items.length-1:
        FOR j FROM 0 TO capacity:
            dp[i+1][j] = dp[i][j]   // skip item
            IF j >= items[i]:
                dp[i+1][j] += dp[i+1][j - items[i]]   // unbounded: use same row
                // bounded: dp[i][j - items[i]]
    RETURN dp[items.length][capacity]
```

## Core Template (Java)

### Grid DP

```java
public int gridDP(int[][] grid) {
    int m = grid.length, n = grid[0].length;
    int[][] dp = new int[m][n];
    dp[0][0] = grid[0][0];
    for (int c = 1; c < n; c++) dp[0][c] = dp[0][c-1] + grid[0][c];
    for (int r = 1; r < m; r++) dp[r][0] = dp[r-1][0] + grid[r][0];
    for (int r = 1; r < m; r++)
        for (int c = 1; c < n; c++)
            dp[r][c] = Math.min(dp[r-1][c], dp[r][c-1]) + grid[r][c];
    return dp[m-1][n-1];
}
```

### Two-Sequence DP (LCS)

```java
public int longestCommonSubsequence(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
            if (s1.charAt(i - 1) == s2.charAt(j - 1))
                dp[i][j] = dp[i - 1][j - 1] + 1;
            else
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
    return dp[m][n];
}
```

### 2D Knapsack (Unbounded)

```java
public int change(int amount, int[] coins) {
    int[][] dp = new int[coins.length + 1][amount + 1];
    for (int i = 0; i <= coins.length; i++) dp[i][0] = 1;
    for (int i = 0; i < coins.length; i++) {
        for (int j = 0; j <= amount; j++) {
            dp[i + 1][j] = dp[i][j];
            if (j >= coins[i]) dp[i + 1][j] += dp[i + 1][j - coins[i]];
        }
    }
    return dp[coins.length][amount];
}
```

## Complexity Cheat Sheet

| Pattern          | Time       | Space      | Notes                              |
|------------------|------------|------------|------------------------------------|
| Grid DP          | O(m · n)   | O(m · n)   | Can often be O(n) with rolling row |
| Two-sequence DP  | O(m · n)   | O(m · n)   | Can reduce to O(min(m,n))          |
| 2D Knapsack      | O(n · W)   | O(n · W)   | W = amount/capacity                |
| Edit Distance    | O(m · n)   | O(m · n)   | Can optimize to O(min(m,n))        |
| Regex Matching   | O(m · n)   | O(m · n)   | s.length=m, p.length=n             |
| Interleaving     | O(m · n)   | O(m · n)   | s1.length=m, s2.length=n           |

## Problems with Full Solutions

### Easy (2)

#### [Unique Paths](https://leetcode.com/problems/unique-paths/) (LeetCode #62)

- **Brute Force:** DFS/backtrack exploring every path from (0,0) to (m-1,n-1). Time O(2^(m+n)) — binary choice at each step; Space O(m+n) — recursion depth.
- **Intuition:** Robot moves only right or down. `dp[r][c]` = number of ways to reach `(r,c)`. Each cell receives paths from above and left: `dp[r][c] = dp[r-1][c] + dp[r][c-1]`. Base: first row and column = 1.
- **Approach:** Initialize `dp[0][*]` and `dp[*][0]` to 1. Fill table row by row.
- **Java Solution:**

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

- **Complexity:** Time O(m · n) — fill m×n DP table, each cell O(1); Space O(m · n) — full DP table stored.

---

#### [Pascal's Triangle](https://leetcode.com/problems/pascals-triangle/) (LeetCode #118)

- **Brute Force:** Recursively compute each element using C(n,k)=C(n-1,k-1)+C(n-1,k) without memoization. Time O(2^numRows) — each element spawns two recursive calls; Space O(numRows) — recursion depth.
- **Intuition:** Each row is built from the previous: `row[j] = prev[j-1] + prev[j]` with 1s at the ends. Classic DP—each element depends on two elements from the row above.
- **Approach:** Build rows one by one. Row 0 = [1]. For row i: start with [1], add prev[j-1]+prev[j] for each middle index, end with [1].
- **Java Solution:**

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> result = new ArrayList<>();
        result.add(List.of(1));
        for (int i = 1; i < numRows; i++) {
            List<Integer> prev = result.get(i - 1);
            List<Integer> row = new ArrayList<>();
            row.add(1);
            for (int j = 1; j < i; j++) {
                row.add(prev.get(j - 1) + prev.get(j));
            }
            row.add(1);
            result.add(row);
        }
        return result;
    }
}
```

- **Complexity:** Time O(numRows²) — sum of 1+2+...+numRows elements built; Space O(1) — excludes output storage, reuse row.

---

### Medium (5)

#### [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/) (LeetCode #1143)

- **Brute Force:** Generate all 2^m subsequences of text1, check each against text2 for containment, take max length. Time O(2^m · n) — 2^m subsequences, each checked in O(n); Space O(m) — recursion depth for subsequence generation.
- **Intuition:** `dp[i][j]` = LCS length of `text1[0..i)` and `text2[0..j)`. If chars match: `dp[i][j] = dp[i-1][j-1] + 1`. Else: `dp[i][j] = max(dp[i-1][j], dp[i][j-1])` (skip one char from either string).
- **Approach:** 2D table with 1-indexed lengths. Fill bottom-up.
- **Java Solution:**

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(), n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
}
```

- **Complexity:** Time O(m · n) — fill (m+1)×(n+1) DP table, each cell O(1); Space O(m · n) — full two-sequence DP table.

---

#### [Unique Paths II](https://leetcode.com/problems/unique-paths-ii/) (LeetCode #63)

- **Brute Force:** DFS/backtrack exploring every path with obstacles; count only valid paths. Time O(2^(m+n)) — right/down choice at each cell; Space O(m+n) — recursion depth.
- **Intuition:** Same as #62 but cells with `obstacleGrid[r][c]==1` are blocked. Paths through obstacles = 0. Base case: if start or any cell in first row/col is blocked, all subsequent cells in that row/col get 0.
- **Approach:** Initialize first row and column, treating obstacles as 0 and stopping propagation.
- **Java Solution:**

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length, n = obstacleGrid[0].length;
        if (obstacleGrid[0][0] == 1) return 0;
        int[][] dp = new int[m][n];
        dp[0][0] = 1;
        for (int j = 1; j < n; j++)
            dp[0][j] = obstacleGrid[0][j] == 1 ? 0 : dp[0][j - 1];
        for (int i = 1; i < m; i++)
            dp[i][0] = obstacleGrid[i][0] == 1 ? 0 : dp[i - 1][0];
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) {
                    dp[i][j] = 0;
                } else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

- **Complexity:** Time O(m · n) — visit each grid cell once, O(1) per cell; Space O(m · n) — full grid DP table.

---

#### [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/) (LeetCode #64)

- **Brute Force:** Try all paths from (0,0) to (m-1,n-1), sum each, take minimum. Time O(2^(m+n)) — explore all right/down paths; Space O(m+n) — recursion depth.
- **Intuition:** `dp[r][c]` = minimum sum to reach `(r,c)`. Either come from above or left: `dp[r][c] = grid[r][c] + min(dp[r-1][c], dp[r][c-1])`. Base: first row and column are cumulative sums.
- **Approach:** Initialize boundaries with cumulative sums from origin, then fill interior.
- **Java Solution:**

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];
        for (int j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j];
        for (int i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

- **Complexity:** Time O(m · n) — fill m×n grid DP table, each cell O(1); Space O(m · n) — full grid DP table stored.

---

#### [Coin Change 2](https://leetcode.com/problems/coin-change-ii/) (LeetCode #518)

- **Brute Force:** Recursively try all combinations: at each step, either use the current coin (if amount allows) or skip to next coin; count when amount reaches 0. Time O(2^n) — use/skip choice per coin; Space O(n) — recursion depth.
- **Intuition:** Count combinations to make `amount` using `coins`. `dp[i][j]` = ways to make `j` using first `i` coins (unbounded—same coin can be reused). Recurrence: use coin `i` zero times: `dp[i-1][j]`; use it: add `dp[i][j-coin]` (same row because unbounded).
- **Approach:** 2D table: `dp[i][0]=1` for all i. For each coin, for each amount from 0 to amount, add the "skip" and "use" contributions.
- **Java Solution:**

```java
class Solution {
    public int change(int amount, int[] coins) {
        int n = coins.length;
        int[][] dp = new int[n + 1][amount + 1];
        for (int i = 0; i <= n; i++) dp[i][0] = 1;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= amount; j++) {
                dp[i + 1][j] = dp[i][j];
                if (j >= coins[i]) {
                    dp[i + 1][j] += dp[i + 1][j - coins[i]];
                }
            }
        }
        return dp[n][amount];
    }
}
```

- **Complexity:** Time O(n · amount) — fill (n+1)×(amount+1) table, each cell O(1); Space O(n · amount) — 2D knapsack DP table.

---

#### [Target Sum](https://leetcode.com/problems/target-sum/) (LeetCode #494)

- **Brute Force:** Try all 2^n assignments of + or - to each number, count how many yield the target sum. Time O(2^n) — sign choice per element; Space O(n) — recursion depth.
- **Intuition:** Assign + or - to each number. Let P = subset with +, S = total sum. We need P - (S - P) = target ⇒ 2P = S + target. So we need a subset with sum = (S + target) / 2. If (S+target) is odd or negative, return 0. Then it's **0/1 knapsack count**: `dp[i][j]` = ways to make sum `j` using first `i` elements. Recurrence: skip `nums[i]` or include it.
- **Approach:** Compute `sum`, check validity of `(sum+target)/2`. Run 0/1 knapsack count DP.
- **Java Solution:**

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int x : nums) sum += x;
        int diff = sum + target;
        if (diff < 0 || diff % 2 != 0) return 0;
        int t = diff / 2;
        int[][] dp = new int[nums.length + 1][t + 1];
        dp[0][0] = 1;
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j <= t; j++) {
                dp[i + 1][j] = dp[i][j];
                if (j >= nums[i]) {
                    dp[i + 1][j] += dp[i][j - nums[i]];
                }
            }
        }
        return dp[nums.length][t];
    }
}
```

- **Complexity:** Time O(n · t) — 0/1 knapsack fill n×t table, each O(1); Space O(n · t) — DP table for subset-sum count.

---

### Hard (3)

#### [Edit Distance](https://leetcode.com/problems/edit-distance/) (LeetCode #72)

- **Brute Force:** Recursively try all operations (insert, delete, replace) at each position when chars differ; explore all paths. Time O(3^(m+n)) — three choices per differing position; Space O(m+n) — recursion depth.
- **Intuition:** `dp[i][j]` = min operations to convert `word1[0..i)` to `word2[0..j)`. If chars match: `dp[i][j] = dp[i-1][j-1]`. Else: 1 + min(insert = dp[i][j-1], delete = dp[i-1][j], replace = dp[i-1][j-1]).
- **Approach:** Base: `dp[i][0]=i` (delete all), `dp[0][j]=j` (insert all). Fill table.
- **Java Solution:**

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i <= m; i++) dp[i][0] = i;
        for (int j = 0; j <= n; j++) dp[0][j] = j;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 1 + Math.min(dp[i - 1][j - 1],
                            Math.min(dp[i - 1][j], dp[i][j - 1]));
                }
            }
        }
        return dp[m][n];
    }
}
```

- **Complexity:** Time O(m · n) — fill (m+1)×(n+1) table for all prefix pairs; Space O(m · n) — edit distance DP table.

---

#### [Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/) (LeetCode #10)

- **Brute Force:** Backtrack: for each pattern position, try matching zero or more chars when `*` appears. Time O(2^(m+n)) — zero vs consume choice at each *; Space O(m+n) — recursion depth.
- **Intuition:** `dp[i][j]` = does `s[0..i)` match `p[0..j)`. Handle `*`: `p[j-1]=='*'` means "zero or more of `p[j-2]`". Zero: dp[i][j-2]. One or more: if s[i-1] matches p[j-2], then dp[i-1][j]. Handle `.` as any char.
- **Approach:** Base: `dp[0][0]=true`. For `p`, skip `x*` patterns for empty string. Fill table, careful with `*` indexing.
- **Java Solution:**

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[0][0] = true;
        for (int j = 2; j <= n; j++) {
            if (p.charAt(j - 1) == '*') {
                dp[0][j] = dp[0][j - 2];
            }
        }
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (p.charAt(j - 1) == '*') {
                    dp[i][j] = dp[i][j - 2];  // zero
                    if (matches(s, p, i - 1, j - 2)) {
                        dp[i][j] = dp[i][j] || dp[i - 1][j];  // one or more
                    }
                } else if (matches(s, p, i - 1, j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
            }
        }
        return dp[m][n];
    }

    private boolean matches(String s, String p, int i, int j) {
        if (j < 0) return false;
        return p.charAt(j) == '.' || s.charAt(i) == p.charAt(j);
    }
}
```

- **Complexity:** Time O(m · n) — fill (m+1)×(n+1) regex match table; Space O(m · n) — DP table for all s,p prefixes.

---

#### [Interleaving String](https://leetcode.com/problems/interleaving-string/) (LeetCode #97)

- **Brute Force:** Try all interleavings of s1 and s2 via recursion (pick char from s1 or s2 at each step). Time O(2^(m+n)) — binary choice at each step; Space O(m+n) — recursion stack depth.
- **Intuition:** `dp[i][j]` = can `s3[0..i+j)` be formed by interleaving `s1[0..i)` and `s2[0..j)`? If s1[i-1]==s3[i+j-1]: try dp[i-1][j]. If s2[j-1]==s3[i+j-1]: try dp[i][j-1]. Base: dp[0][0]=true; dp[i][0] = s1[0..i)==s3[0..i); dp[0][j] similarly.
- **Approach:** Check len(s1)+len(s2)==len(s3) first. Fill table with OR of valid transitions.
- **Java Solution:**

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length(), n = s2.length();
        if (m + n != s3.length()) return false;
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[0][0] = true;
        for (int i = 1; i <= m && s1.charAt(i - 1) == s3.charAt(i - 1); i++)
            dp[i][0] = true;
        for (int j = 1; j <= n && s2.charAt(j - 1) == s3.charAt(j - 1); j++)
            dp[0][j] = true;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                char c = s3.charAt(i + j - 1);
                if (s1.charAt(i - 1) == c && dp[i - 1][j]) dp[i][j] = true;
                if (s2.charAt(j - 1) == c && dp[i][j - 1]) dp[i][j] = true;
            }
        }
        return dp[m][n];
    }
}
```

- **Complexity:** Time O(m · n) — fill (m+1)×(n+1) interleave table; Space O(m · n) — two-sequence DP table.

---

## Common Mistakes

- **Off-by-one in two-sequence DP:** Use 1-based indices for lengths: `s1.charAt(i-1)` corresponds to `dp[i][j]` for prefix of length i.
- **Grid base cases:** For path counting, first row and column often need special handling (obstacles can block entire row/col).
- **Regular Expression `*`:** The pattern `a*` matches zero or more `a`. Zero means skip 2 chars in p (`dp[i][j-2]`); one or more means consume one char in s (`dp[i-1][j]`) only if s[i-1] matches the char before `*` (p[j-2]).
- **Target Sum:** Must check `(sum+target)` is non-negative and even before dividing by 2. Otherwise no valid partition.
- **Coin Change 2 unbounded vs bounded:** Unbounded uses `dp[i+1][j - coins[i]]` (same row); bounded would use `dp[i][j - coins[i]]` (previous row).
- **Interleaving base case:** `dp[i][0]` requires s1[0..i) to exactly match s3[0..i)—check character by character.

## Pattern Variations

| Variation              | Example           | Key Technique                              |
|------------------------|-------------------|--------------------------------------------|
| Path counting          | #62, #63          | dp[r][c] = dp[r-1][c] + dp[r][c-1]         |
| Min path sum           | #64               | dp[r][c] = grid[r][c] + min(up, left)      |
| Pascal / triangular    | #118              | row[j] = prev[j-1] + prev[j]               |
| Two-sequence LCS       | #1143             | match → diagonal+1; else max(skip either)   |
| Edit distance          | #72               | match → diag; else 1+min(insert,del,rep)   |
| Unbounded knapsack     | #518              | dp[i+1][j] += dp[i+1][j-coin]               |
| 0/1 knapsack count     | #494              | subset sum = (S+target)/2                   |
| Regex matching         | #10               | handle `*` with zero or consume            |
| Interleaving           | #97               | dp[i][j] = (s1 match) or (s2 match)        |
